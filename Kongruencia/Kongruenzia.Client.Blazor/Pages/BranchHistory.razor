@using Kongruencia.Data.Domain.Models
@using System.Net.Http
@using System.Web;
@using ChartJs.Blazor.Charts
@using ChartJs.Blazor.ChartJS.LineChart
@using ChartJs.Blazor.ChartJS.Common.Properties
@using ChartJs.Blazor.ChartJS.Common.Time
@using ChartJs.Blazor.ChartJS.Common.Enums
@using ChartJs.Blazor.ChartJS.Common.Axes
@using ChartJs.Blazor.ChartJS.Common.Axes.Ticks
@using ChartJs.Blazor.ChartJS.Common.Handlers

@inject HttpClient Http

@page "/project/{ProjectName}/branch/{BranchName}"

<h1>Branch History</h1>
<h2>Project: @(ProjectName)</h2>
<h3>Branch: @(BranchName)</h3>

@if (Coverages is null)
{
    <p>Loading ...</p>
}
else
{
    <p>Coverages: @(Coverages.Length)</p>
    <table>
        <tr>
            <th>#</th>
            <th>Time</th>
            <th>Statements</th>
            <th>Branches</th>
            <th>Functions</th>

        </tr>
        @foreach (var coverage in Coverages)
        {
            <tr>
                <td>@(coverage.BuildNumber)</td>
                <td>@(coverage.Timestamp)</td>
                <td>@(coverage.Metrics.coveredstatements + " / " + coverage.Metrics.statements)</td>
                <td>@(coverage.Metrics.coveredconditionals + " / " + coverage.Metrics.conditionals)</td>
                <td>@(coverage.Metrics.coveredmethods + " / " + coverage.Metrics.methods)</td>
            </tr>
        }
    </table>

    <ChartJsLineChart @ref="_lineChart" Config="@_lineConfig" Width="600" Height="400" />
}

@code {
    [Parameter]
    public string ProjectName { get; set; }
    [Parameter]
    public string BranchName { get; set; }
    public Coverage[] Coverages { get; set; }


    private LineConfig _lineConfig;
    private ChartJsLineChart _lineChart;


    protected override async Task OnInitializedAsync()
    {
        Coverages = await Http.GetJsonAsync<Coverage[]>(
            String.Format(
                    "https://localhost:5001/api/coverages?productName={0}&branchName={1}",
                HttpUtility.UrlEncode(ProjectName),
                HttpUtility.UrlEncode(BranchName)

            ));

        _lineConfig = new LineConfig
        {
            Options = new LineOptions
            {
                Responsive = true,
                Title = new OptionsTitle
                {
                    Display = true,
                    Text = "Statement Coverage"
                },
                Legend = new Legend
                {
                    Position = Position.Right,
                    Labels = new LegendLabelConfiguration
                    {
                        UsePointStyle = true
                    }
                },
                Tooltips = new Tooltips
                {
                    Mode = InteractionMode.Nearest,
                    Intersect = false
                },
                Scales = new Scales
                {
                    xAxes = new List<CartesianAxis>
            {
                        new TimeAxis
                        {
                            Distribution = TimeDistribution.Linear,
                            Ticks = new TimeTicks
                            {
                                Source = TickSource.Data
                            },
                            Time = new TimeOptions
                            {
                                Unit = TimeMeasurement.Millisecond,
                                Round = TimeMeasurement.Millisecond,
                                TooltipFormat = "DD.MM.YYYY HH:mm:ss",
                                DisplayFormats = TimeDisplayFormats.DE_CH
                            },
                            ScaleLabel = new ScaleLabel
                            {
                                LabelString = "Time"
                            }
                        }
                    },
                },
                Hover = new LineOptionsHover
                {
                    Intersect = true,
                    Mode = InteractionMode.Y
                }
            }
        };

        var statementsDataset = new LineDataset<TimeTuple<int>>
        {
            BackgroundColor = "#3054e3",
            BorderColor = "#3054e3",
            Label = "Total Statements",
            Fill = false,
            BorderWidth = 2,
            PointRadius = 3,
            PointBorderWidth = 1,
            SteppedLine = SteppedLine.Before
        };
        statementsDataset.AddRange(Coverages.Select(c => new TimeTuple<int>(new Moment(c.Timestamp), c.Metrics.statements)));

        var coveredStatementsDataset = new LineDataset<TimeTuple<int>>
        {
            BackgroundColor = "#3fe330",
            BorderColor = "#3fe330",
            Label = "Covered Statements",
            Fill = false,
            BorderWidth = 2,
            PointRadius = 3,
            PointBorderWidth = 1,
            SteppedLine = SteppedLine.Before
        };
        coveredStatementsDataset.AddRange(Coverages.Select(c => new TimeTuple<int>(new Moment(c.Timestamp), c.Metrics.coveredstatements)));

        var uncoveredStatementsDataset = new LineDataset<TimeTuple<int>>
        {
            BackgroundColor = "#e33030",
            BorderColor = "#e33030",
            Label = "Uncovered Statements",
            Fill = false,
            BorderWidth = 2,
            PointRadius = 3,
            PointBorderWidth = 1,
            SteppedLine = SteppedLine.Before
        };
        uncoveredStatementsDataset.AddRange(Coverages.Select(c => new TimeTuple<int>(new Moment(c.Timestamp), c.Metrics.statements - c.Metrics.coveredstatements)));

        _lineConfig.Data.Datasets.Add(statementsDataset);
        _lineConfig.Data.Datasets.Add(coveredStatementsDataset);
        _lineConfig.Data.Datasets.Add(uncoveredStatementsDataset);
    }

}